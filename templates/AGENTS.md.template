# Agent Instructions

This repository implements **{{SPEC_ID}}: {{SPEC_TITLE}}**.

## Shell Commands

- Use `git --no-pager` for all git commands that produce output (diff, log, show, branch)
- Avoid interactive commands that wait for user input

## Planning and Clarification

### Always Plan First

Before implementing any changes, create a plan of what you're going to do:
- Outline the steps you'll take
- Identify files that will be modified or created
- Consider potential impacts on other parts of the codebase

### Ask Questions When Unclear

If anything is unclear or ambiguous:
- Ask the user for clarification before proceeding
- Provide suggestions or options when asking (don't just ask open-ended questions)
- Example: "Should I use approach A (faster, less flexible) or approach B (slower, more extensible)?"

### Multiple Tasks

When the user requests multiple tasks:
1. Create a todo list of all tasks
2. Present the list to the user and ask if they want to proceed
3. Work through tasks sequentially, marking each as complete
4. Keep the user informed of progress

Example:
```
## Task List

1. [ ] Add user validation endpoint
2. [ ] Update database schema
3. [ ] Add tests for new endpoint
4. [ ] Update API documentation

Shall I proceed with these tasks in order?
```

## Documentation

### Keep README.md Updated

After implementing changes, always check if the README.md needs updating:
- New features should be documented
- Changed behavior should be reflected
- Installation or usage instructions may need updates

If updates are needed, propose a plan of changes to be added to the README.md before making them.

## Before Implementing Any Task

You MUST read and understand:

1. **The Specification**: `.github/spec/spec.md`
   - Contains the requirements (SHALL/MUST statements)
   - Contains scenarios (GIVEN/WHEN/THEN) for validation

2. **The Standards**: `.github/standards/`
   - Contains coding standards and conventions to follow
   - All implementations MUST comply with these standards

3. **Spec Dependencies** (if any): `scratchpad/contexts/`
   - Contains shallow clones of repos that implement specs this project depends on
   - Use these to understand APIs, data formats, or services you're integrating with
   - **NEVER write to `scratchpad/contexts/`** - it is read-only reference material

## Scratchpad Directory

The `scratchpad/` directory is gitignored and contains two subdirectories:

### `scratchpad/contexts/` - Read-Only Reference

This directory contains cloned repositories from spec dependencies. If any, use it to:
- Understand the API contracts you're consuming
- Reference implementation patterns from dependent specs
- Look up data structures and interfaces

**IMPORTANT:** NEVER modify files in `scratchpad/contexts/`. It exists only for understanding what you're implementing against.

### `scratchpad/agents/` - Your Workspace

This directory is your workspace for:
- Implementation plans and notes
- Design documents and diagrams
- Summaries of research or analysis
- Any working documents that shouldn't be in git history

Use `scratchpad/agents/` freely for any documents you create during implementation. These files are gitignored and won't pollute the repository history.

## Implementation Workflow

1. Use `/implement` to find the next issue to work on
2. Issues are linked to spec requirements
3. Each issue body contains:
   - The requirement being implemented
   - Scenarios to validate the implementation
4. Create branches, implement, commit, push, and create PRs

## Issue Labels

- `spec:{{SPEC_ID}}` - All issues related to this spec
- Issues use GitHub's "blocked by" relationship for dependencies

## Validation

Before marking an issue complete, verify:
- All scenarios in the issue pass
- Code follows the standards in `.github/standards/`
- Tests are written for the implementation

## Testing

Refer to `.github/standards/` for testing conventions and requirements specific to this project.

## Branch Naming

Refer to `.github/standards/` for branch naming conventions specific to this project.

## Pull Requests

When creating PRs:
- Reference the issue number in the PR title or body
- Include a summary of changes
- Ensure CI passes before requesting review

## Committing Changes

### Update CHANGELOG.md

Before committing, check if the changes should be documented in CHANGELOG.md:

- **feat:** Add to "Added" section
- **fix:** Add to "Fixed" section
- **perf:** Add to "Performance" section
- **refactor!:** or any breaking change: Add to "Breaking Changes" section
- **deprecation:** Add to "Deprecated" section
- **removal:** Add to "Removed" section
- **security:** Add to "Security" section

If CHANGELOG.md doesn't have an "Unreleased" section, add one at the top. Group changes under the appropriate heading.

### Create a Commit Plan

Present the commit plan and ask the user if they want to proceed. Never commit automatically without confirmation.

1. Review all modified files
2. Group related changes into logical commits
3. Draft commit messages for each group
4. Present the plan to the user

Example:
```
## Commit Plan

1. feat: add user validation endpoint
   - src/api/users.ts
   - src/validators/user.ts

2. test: add tests for user validation
   - tests/api/users.test.ts

3. docs: update API documentation
   - decisions/api.md

Ready to commit? (yes/no/modify)
```

### Logical Commits

When changes span multiple files or concepts, split them into logical commits:
- Group related changes into separate commits
- Each commit should represent a single logical unit of work
- Example: separate "add new feature" from "update tests" from "update documentation"

### Partial Staging

When a single file contains multiple unrelated changes:
- Stage only the lines related to the current commit
- Use partial staging (`git add -p`) to keep commits focused
- Do not mix unrelated changes in one commit

### Commit Message Format

Follow conventional commit format:
- `feat:` new features
- `fix:` bug fixes
- `refactor:` code changes that don't add features or fix bugs
- `docs:` documentation changes
- `test:` test-only changes
- `perf:` performance improvements
- `ci:` CI/CD changes
- `build:` build system changes
- `chore:` maintenance tasks (dependencies, tooling, etc.)

### Breaking Changes

If a change breaks backward compatibility:
- Add `!` before the colon: `feat!:`, `fix!:`, `refactor!:`
- Inform the user about the breaking change before committing
- Example: `feat!: change API response format`

Always highlight breaking changes to the user so they can make an informed decision about the commit.
